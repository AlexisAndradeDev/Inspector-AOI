El nombre del método es "circular_fiducials"



[
[[x1, y1, x2, y2 Fiducial 1], [x1, y1, x2, y2 Fiducial 2]], [min diametro Fiducial 1, min diametro Fiducial 2], [max diametro, max diametro], 
[min perfeccion del circulo, min perfeccion del circulo], [max perfeccion del circulo, max perfeccion del circulo], angulo deseado entre los 2 fiduciales,
[coordenadas a las que se debe trasladar el fiducial 1 despues de rotar], 
[ [['Filtro secundario fiducial 1', params], ['Filtro secundario fiducial 1', params]], [['Filtro secundario 2', params], ['Filtro secundario fiducial 2', params]] ]
]

EJEMPLO:

[
[[970, 500, 970+249, 500+222], [930, 940, 930+308, 940+251]], [20, 20], [60, 60], [0.85, 0.85], [1.2, 1.2], 90, [1094, 611],
[ [["medianBlur", 9], ["reverseBinary", [[40, 40, 40], [255, 255, 255]] ]], [["medianBlur", 9], ["reverseBinary", [[40, 40, 40], [255, 255, 255]] ]] ],
]




NOTA: Este método fue el primero en programarse. El cálculo del centro del círculo no es exacto, así que
      es mejor utilizar otro método que realice una función parecida, como "rotation_points_and_translation_point",
      que utiliza el centroide del contorno, lo cual es más preciso, además de que puede utilizar varios filtros
      de contornos, incluyendo circularidad.
