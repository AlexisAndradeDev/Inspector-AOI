[
 ignorar_status_bad, status_necesario_para_ser_good,
 [algoritmo_al_que_está_encadenado, status_necesario_del_algoritmo_al_que_está_encadenado],
 origen_del_algoritmo, luz, nombre_del_algoritmo, coordenadas, [tableros_en_los_que_NO_se_inspeccionará], función_de_inspección, 
 [parámetros_de_la_función_de_inspección],
 filtros_secundarios
],


donde:

ignorar_status_bad: True/False.
    Si es True, y el algoritmo obtiene status "bad", el punto de inspección que lo contiene no
    modificará su status por culpa de este algoritmo.

status_necesario_para_ser_good: si la función de inspección obtiene el status que se establece, 
    su status se transformará a "good". Si no obtiene el status que se indicó,
    y el status que obtuvo no es un status especial (como "failed"), el status
    del algoritmo se transformará a "bad".
    Por ejemplo:
        El status necesario es "good", y la función de inspección obtiene "good":
            el status del algoritmo es "good"
        El status necesario es "good", y la función de inspección obtiene "bad":
            el status del algoritmo es "bad"
        El status necesario es "bad", y la función de inspección obtiene "bad":
            el status del algoritmo es "good"
        El status necesario es "bad", y la función de inspección obtiene "good":
            el status del algoritmo es "bad"
        El status necesario es "good", y la función de inspección obtiene "failed":
            el status del algoritmo es "failed"
        El status necesario es "bad", y la función de inspección obtiene "failed":
            el status del algoritmo es "failed"
        
        Experimental, no encuentro un uso práctico a lo siguiente:
            El status necesario es "failed", y la función de inspección obtiene "failed":
                el status del algoritmo es "good"
            El status necesario es "failed", y la función de inspección obtiene "good":
                el status del algoritmo es "bad"

Si no se quiere encadenar el algoritmo a ningún otro algoritmo, dejar algoritmo_al_que_está_encadenado y status_necesario_del_algoritmo_al_que_está_encadenado
como None y None.

origen_del_algoritmo: si se quiere que las coordenadas de origen sea el punto de inspección, dejar como $inspection_point
    Si se quiere que sea otro algoritmo, asignarle el nombre de ese algoritmo entre comillas.
    
luz: "white"/"ultraviolet"
coordenadas: [x1,y1,x2,y2]
    Las coordenadas toman origen en origen_del_algoritmo

tableros_en_los_que_NO_se_inspeccionará: lista con los tableros en los que no se inspeccionará el algoritmo.
    Ejemplo: Hay 4 tableros en un panel, en los tableros 1 y 3 se inspeccionará el algoritmo; en los tableros 2 y 4 no se
    inspeccionará el algoritmo (no se inspeccionará y no aparecerá en los resultados de estos tableros).
        tableros_en_los_que_NO_se_inspeccionará sería: [2,4]
    Si quiere inspeccionarse en los tableros 1, 2 y 3, sería: [4]
        El tablero 4 ignoraría este algoritmo.
    Si se inspeccionará en todos los tableros, se debe dejar una lista vacía [].

función_de_inspección: "b", "m", entre otros.

parámetros_de_la_función_de_inspección: Documentacion/Otros/Funciones-de-inspeccion/

filtros_secundarios: documentacion/otros/filtros-secundarios/
